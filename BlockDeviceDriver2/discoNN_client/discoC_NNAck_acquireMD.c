/*
 * Copyright (C) 2010 - 2020 by Cloud Computing Center for Mobile Applications
 * Industrial Technology Research Institute
 *
 * discoC_NNAck_acquireMD.c
 *
 * Provide function to process ack of metadata alloc/query request from namenode
 *
 */
#include <linux/version.h>
#include <linux/blkdev.h>
#include <net/sock.h>
#include <linux/kthread.h>
#include <linux/delay.h>
#include "../common/discoC_sys_def.h"
#include "../common/common_util.h"
#include "../common/dms_kernel_version.h"
#include "../common/discoC_mem_manager.h"
#include "../metadata_manager/metadata_manager.h"
#include "../metadata_manager/metadata_cache.h"
#include "../connection_manager/conn_manager_export.h"
#include "../common/thread_manager.h"
#include "../config/dmsc_config.h"
#include "discoC_NNC_Manager_api.h"
#include "discoC_NNC_worker.h"
#include "../flowcontrol/FlowControl.h"
#include "discoC_NNClient.h"
#include "discoC_NN_protocol.h"
#include "discoC_NNAck_acquireMD.h"
#include "discoC_NNMData_Request.h"
#include "discoC_NNC_workerfunc_reportMD.h"
#include "discoC_NNMDReqPool.h"

/*
 * _nnack_find_acquireMDReq: find corresponding metadata request base on request ID
 * @mem: packet string from namenode
 * @nnReq_ID: target request ID for finding request data structure
 * @ptr_shift: how many bytes shift from @mem which means finish the processing the metadata header
 *             for return to caller
 * @num_lrs:  for return to caller: it means how many metadata items in metadata header
 * @nn_md_id: metadata ID generated by namenode (deprecated)
 *
 * Return: Metadata request that match to @nnReq_ID
 */
static NNMData_Req_t *_nnack_find_acquireMDReq (int8_t *mem, uint64_t nnReq_ID,
        uint32_t *ptr_shift, uint16_t *num_lrs, uint64_t *nn_md_id)
{
    NNMData_Req_t *nnMDReq;
    CN2NN_getMDResp_mdhder_t *mdhder;
    int8_t *curptr;

    nnMDReq = NULL;
    curptr = mem;

    //TODO: If we have IP and port, we can search and set last rcvID here, but it affect perf
    //discoNNC.nnReq_last_rcvID = nnReq_ID;
    //atomic_dec(&discoNNC.num_nnReq_noResp);

    mdhder = (CN2NN_getMDResp_mdhder_t *)curptr;
    NNProto_getMDResp_MDheader_ntoh(mdhder);
    dms_printk(LOG_LVL_DEBUG,
            "DMSC DEBUG got nn resp rid %llu num lrs %d\n",
            mdhder->metadata_ID, mdhder->num_metadata_items);

    *num_lrs = mdhder->num_metadata_items;
    *nn_md_id = mdhder->metadata_ID;
    *ptr_shift = sizeof(CN2NN_getMDResp_mdhder_t);

    barrier(); //NOTE: previous experience shows that remove barrier cause system crash, reason: unknow
    nnMDReq = NNMDReq_find_ReqPool((uint32_t)nnReq_ID);
    if (IS_ERR_OR_NULL(nnMDReq)) {
        dms_printk(LOG_LVL_INFO,
                "DMSC INFO nn req has been GONE nn id %llu\n", nnReq_ID);
    } else {
        NNMDReq_cancel_timer(nnMDReq);
        nnMDReq->nnMDReq_comm.t_rcvReqAck = jiffies_64;

        NNClient_dec_numReq_NoResp(nnMDReq->nnSrv_client);
        NNClient_set_last_rcvReqID(nnMDReq->nnSrv_client, nnReq_ID);
    }

    return nnMDReq;
}

/*
 * _nnack_add_acquireMDReq_latency: add request latency information to flow control module for perf monitoring
 * @nnMDReq: metadata request that has latency information
 */
static void _nnack_add_acquireMDReq_latency (NNMData_Req_t *nnMDReq)
{
    discoC_NNClient_t *myClient;
    ReqCommon_t *nnR_comm;
    int32_t optype;

    nnR_comm = &(nnMDReq->nnMDReq_comm);
    myClient = nnMDReq->nnSrv_client;

    if (nnMDReq->nnMDReq_comm.ReqOPCode == REQ_NN_ALLOC_MDATA_NO_OLD) {
        optype = NN_RESPONSE_SUB_TYPE_ALLOC_METADATA_NoOld;
    } else if (nnMDReq->nnMDReq_comm.ReqOPCode == REQ_NN_ALLOC_MDATA_AND_GET_OLD) {
        optype = NN_RESPONSE_SUB_TYPE_ALLOC_METADATA_WithOld;
    } else {
        optype = NN_RESPONSE_SUB_TYPE_QUERY_METADATA;
    }

    add_req_response_time(nnR_comm->t_sendReq,
            nnR_comm->t_rcvReqAck, 0, RES_TYPE_NN, optype,
            myClient->nnSrv_IPAddr, myClient->nnSrv_port,
            (nnMDReq->nnMDReq_ioaddr.lbid_len << BIT_LEN_DMS_LB_SIZE));
}

/*
 * _nnack_alloc_MDArray: alloc metadata item array base on num_lrs
 * @nnMDReq: MData Request that own the metadata array
 * @pkt_len: packet length of namenode metadata response
 * @num_lrs: number of metadata items in metadata response
 *
 * Return: 0: allocate memory for metadata array success
 *         -ENOMEM: fail allocate memory
 *         -ENODEV: namenode only reply response with packet size <= 10 bytes.
 *                  It happens that namenode encounter some exception
 */
static int32_t _nnack_alloc_MDArray (NNMData_Req_t *nnMDReq, uint32_t pkt_len,
        uint16_t num_lrs)
{
    metadata_t *my_MData;
    int16_t curr_lrs;

    my_MData = nnMDReq->MetaData;

    if (pkt_len <= sizeof(CN2NN_getMDResp_mdhder_t) || num_lrs == 0) {
        dms_printk(LOG_LVL_WARN,
                "DMSC WARN nn reply null metadata ior %u ioSegReq %u\n",
                nnMDReq->nnMDReq_comm.ReqID, nnMDReq->nnMDReq_comm.CallerReqID);
        dms_printk(LOG_LVL_WARN, "DMSC WARN Got wrong pkt size %u "
                "or %u MData item (== 0)\n", pkt_len, num_lrs);

        my_MData->array_metadata = NULL;
        my_MData->num_MD_items = 0;

        if (nnMDReq->nnMDReq_comm.ReqOPCode == REQ_NN_QUERY_MDATA_READIO ||
                nnMDReq->nnMDReq_comm.ReqOPCode == REQ_NN_QUERY_TRUE_MDATA_READIO) {
            dms_printk(LOG_LVL_WARN, "DMSC WARN nn reply null loc when read\n");
        } else if (NNMDReq_check_alloc(nnMDReq) ||
                nnMDReq->nnMDReq_comm.ReqOPCode == REQ_NN_QUERY_MDATA_WRITEIO) {
            dms_printk(LOG_LVL_WARN, "DMSC WARN nn reply null loc when write\n");
        }

        return -ENODEV;
    }

    curr_lrs = num_lrs;

    my_MData->array_metadata = discoC_mem_alloc(sizeof(metaD_item_t *)*curr_lrs,
            GFP_NOWAIT | GFP_ATOMIC);
    if (unlikely(IS_ERR_OR_NULL(my_MData->array_metadata))) {
        my_MData->num_MD_items = 0;
        dms_printk(LOG_LVL_WARN,
                "DMSC WARN fail alloc mem for locs with len_lr > 0\n");
        DMS_WARN_ON(true);
        return -ENOMEM;
    }
    my_MData->num_MD_items = curr_lrs;
    my_MData->num_invalMD_items = 0;

    return 0;
}

/*
 * _nnack_update_MDItem_state: update metadata state by compare number of replica in
 *          metadata item and volume default replica
 * @mdstat: metadata state return by namenode (MData_VALID and MData_INVALID)
 * @volReplica: number of volume default replica
 * @loc_ptr: metadata item
 * @allocMD: whether this is a allocate metadata operation
 * @lr_index: locate index
 *
 * RR: [0 (disable), 1 (enable)], Replica: [0 (vol > MD), 1 (vol = MD)], NN: valide, inval
 * (RR, Replica, NN) = (0, 0, inval) : keep inval
 * (RR, Replica, NN) = (0, 0, valid) : keep valid
 * (RR, Replica, NN) = (0, 1, inval) : keep inval
 * (RR, Replica, NN) = (0, 1, valid) : keep valid
 * (RR, Replica, NN) = (1, 0, inval) : keep inval
 * (RR, Replica, NN) = (1, 0, valid) : update to MData_VALID_LESS_REPLICA
 * (RR, Replica, NN) = (1, 1, inval) : keep inval
 * (RR, Replica, NN) = (1, 1, valid) : keep valid
 *
 * NOTE: when clientnode send a MData request with : REQ_NN_ALLOC_MDATA_AND_GET_OLD
 *       namenode will put allocate metadata at 1st MDitem
 *       if has old metadata, namenode will put old metadata from 2nd MDitem ~ xnd MDitem
 *       lr_index = 0, the metadata pointer point to new metadata
 *       lr_index > 0, old metadata (keep original state - read-only location)
 */
static void _nnack_update_MDItem_state (int16_t mdstat, uint16_t volReplica,
        metaD_item_t *loc_ptr, bool allocMD, int32_t lr_index)
{
    if (MData_VALID != mdstat) {
        loc_ptr->mdata_stat = mdstat;
        return;
    }

    if (loc_ptr->num_dnLoc < volReplica && dms_client_config->dms_RR_enabled) {
        if (allocMD) {
            if (lr_index == 0) { //First W with or without get old
                loc_ptr->mdata_stat = MData_VALID_LESS_REPLICA;
            } else { //First W old location
                loc_ptr->mdata_stat = mdstat;
            }
        } else { //Read or OVW
            loc_ptr->mdata_stat = MData_VALID_LESS_REPLICA;
        }
    } else {
        loc_ptr->mdata_stat = mdstat;
    }

#if 0 //TODO: this will create a DN record at flow control.
      //      we can refactor this
    len_datanode_loc = loc_ptr->num_dnLoc;
    for (i = 0; i < len_datanode_loc; i++) {
        local_dl_ptr = &loc_ptr->udata_dnLoc[i];
        Check_DN_Resources_Is_Available(local_dl_ptr->ipaddr, local_dl_ptr->port);
        add_res_to_fc_group_by_hostname(local_dl_ptr->ipaddr, local_dl_ptr->port,
                drv->vol_fc_group, RES_TYPE_DN);
    }
#endif
}

/*
 * _nnack_update_flowctrl: get flow control value from packet and update to flow control module
 * @curptr: packet pointer that contains flow control value from namenode
 * @nn_res: target resource for update (namenode connection resources)
 */
static void _nnack_update_flowctrl (int8_t *curptr, dms_res_item_t *nn_res)
{
    CN2NN_getMDResp_fcpkt_t fcItem;

    NNProto_getMDResp_FlowCtrl_ntoh(&fcItem, curptr);
    update_resource_rate(nn_res,
                fcItem.rate_SlowStart, fcItem.rate_SlowStartMaxReqs, fcItem.rate_AgeTime,
                fcItem.rate_Alloc, fcItem.rate_AllocMaxReqs);
}

/*
 * _do_normal_parse:
 *     Parse packet format and fill content to metadata data structure
 * @mem: response body byte array received from socket by socket receiver
 * @nnMDReq: which request has the metadata data structure to hold response from namenode
 * @num_lrs: how many metadata item in packet
 * @totallen: error code when parsing to return to caller
 *
 * Return: which metadata request pair with the response (namenode need return
 *         request id in request packet)
 *
 * NOTE: plz refer to doc/readme.txt and document to know packet format
 */
/*
 * Return: 0: parse OK
 *         -ENOMEM: fail allocate memory to metadata array
 *         -ENODEV: namenode encounter some execption
 *
 */
static int32_t _do_normal_parse (int8_t *mem, NNMData_Req_t *nnMDReq,
        uint16_t num_lrs, int16_t totallen)
{
    metadata_t *my_MData;
    UserIO_addr_t *ioaddr;
    metaD_item_t *mdItem_ptr;
    uint64_t startLB;
    uint32_t ptr_shift, i;
    int32_t alloc_ret;
    uint16_t *num_invalMD_ptr;
    int8_t *curptr;
#ifdef DISCO_ERC_SUPPORT
    mdata_prot_t blkmdType;
#endif

    alloc_ret = _nnack_alloc_MDArray(nnMDReq, totallen, num_lrs);
    if (alloc_ret) {
        return alloc_ret;
    }

    ioaddr = &nnMDReq->nnMDReq_ioaddr;
    curptr = mem;
    ptr_shift = 0;

    my_MData = nnMDReq->MetaData;
    startLB = ioaddr->lbid_start;

    for (i = 0; i < num_lrs; i++) {
        my_MData->array_metadata[i] = MData_alloc_MDItem();
        if (unlikely(IS_ERR_OR_NULL(my_MData->array_metadata[i]))) {
            dms_printk(LOG_LVL_WARN, "DMSC WARN fail alloc MDItem\n");;
            continue;
        }
        mdItem_ptr = my_MData->array_metadata[i];
        memset(mdItem_ptr, 0, sizeof(metaD_item_t));

        num_invalMD_ptr = &(my_MData->num_invalMD_items);

        do {
#ifdef DISCO_ERC_SUPPORT
            if (REQ_NN_QUERY_TRUE_MDATA_READIO ==
                    nnMDReq->nnMDReq_comm.ReqOPCode) {
                DMS_MEM_READ_NEXT(curptr, &blkmdType, sizeof(int16_t));
                blkmdType = ntohs(blkmdType);

                if (MDPROT_ERC == blkmdType) {
                    ptr_shift = NNAckERC_MDItem_ntoh_order(mdItem_ptr, startLB, curptr);
                    break;
                }
            }
#endif

            ptr_shift = NNProto_getMDResp_MDItem_ntoh(mdItem_ptr, startLB, curptr);
        } while (0);

        curptr += ptr_shift;

        if (REQ_NN_QUERY_TRUE_MDATA_READIO == nnMDReq->nnMDReq_comm.ReqOPCode) {
            MData_set_TrueMD(mdItem_ptr);
        }
        _nnack_update_MDItem_state(mdItem_ptr->mdata_stat, nnMDReq->volReplica, mdItem_ptr,
                NNMDReq_check_alloc(nnMDReq), i);
        if (MData_INVALID == mdItem_ptr->mdata_stat) {
            (*num_invalMD_ptr)++;
        }

        if (MData_INVALID != mdItem_ptr->mdata_stat &&
                NNMDReq_check_alloc(nnMDReq)) {

            if (nnMDReq->nnReq_setOVW_fn(nnMDReq->usr_pdata, startLB,
                    mdItem_ptr->num_hbids)) {
                dms_printk(LOG_LVL_WARN,
                        "DMSC WARN fail set ovw due to volume %u not exist\n",
                        ioaddr->volumeID);
            }
        }

        startLB += mdItem_ptr->num_hbids;
    }

    _nnack_update_flowctrl(curptr, nnMDReq->nnSrv_client->nnSrv_resource);

    return 0;
}

/*
 * parse_namenode_response:
 *     a. find corresponding acquire metadata request by request id
 *     b. parse response packet into metadata structure
 * @mem: response body byte array received from socket by socket receiver
 * @resppkt: response header packet receive by socket receiver
 * @retcode: error code when parsing to return to caller
 *
 * Return: which metadata request pair with the response (namenode need return
 *         request id in request packet)
 *
 * NOTE: plz refer to doc/readme.txt and document to know packet format
 */
static NNMData_Req_t *parse_namenode_response (int8_t *mem,
        CN2NN_MDResp_hder_t *resppkt, int32_t *retcode)
{
    NNMData_Req_t *nnMDReq;
    uint64_t nn_md_id;
    uint32_t ptr_shift;
    uint16_t num_lrs;
    int8_t *curptr;

    curptr = mem;
    ptr_shift = 0;
    num_lrs = 0;
    nnMDReq = _nnack_find_acquireMDReq(curptr, resppkt->request_ID, &ptr_shift,
            &num_lrs, &nn_md_id);
    if (IS_ERR_OR_NULL(nnMDReq)) {
        *retcode = -EFAULT;
        return NULL;
    }

    curptr += ptr_shift;

    dec_res_rate_max_reqs(nnMDReq->nnSrv_client->nnSrv_resource);

    _nnack_add_acquireMDReq_latency(nnMDReq);

    *retcode = _do_normal_parse(curptr, nnMDReq, num_lrs, resppkt->resp_data_size);

    return nnMDReq;
}

/*
 * NNAckProc_acquireMDReq: Process response of acquire metadata request from namenode
 *     a. parse response packet into metadata structure
 *     b. add metadata from namenode to local cache
 *     c. finish request by notify caller through callback function
 * @mem: response body byte array received from socket by socker receive
 * @resppkt: response header packet receive by socket receiver
 */
void NNAckProc_acquireMDReq (int8_t *mem, CN2NN_MDResp_hder_t *resppkt)
{
    NNMData_Req_t *nnMDReq;
    metadata_t *my_metaD;
    UserIO_addr_t *ioaddr;
    int32_t retCode, mdReq_res;
    bool mdcache_enable;

    nnMDReq = parse_namenode_response(mem, resppkt, &mdReq_res);
    if (unlikely(IS_ERR_OR_NULL(nnMDReq))) {
        return;
    }

    ioaddr = &nnMDReq->nnMDReq_ioaddr;
    my_metaD = nnMDReq->MetaData;

    if (mdReq_res == 0) {
        mdcache_enable = NNMDReq_MData_cacheEnable(nnMDReq);
        if (update_volume_MDCache(my_metaD, ioaddr->volumeID, ioaddr->lbid_start,
                ioaddr->lbid_len, mdcache_enable)) {
            dms_printk(LOG_LVL_DEBUG, "DMSC DEBUG fail add metadata to cache\n");
        }
    }

    if ((retCode = nnMDReq->nnReq_endfn(nnMDReq->MetaData, nnMDReq->usr_pdata,
            &nnMDReq->nnMDReq_comm, mdReq_res))) {
        dms_printk(LOG_LVL_WARN,
                "DMSC WARN fail exec MD req end function ret %d\n", retCode);
    }

    NNMDReq_deref_Req(nnMDReq);
    NNMDReq_free_Req(nnMDReq);
}
